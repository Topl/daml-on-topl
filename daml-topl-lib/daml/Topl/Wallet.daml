module Topl.Wallet where

  import DA.Assert
  import DA.Optional
  import Topl.Levels
  import DA.List

  data AcceptedInteraction = AcceptedInteraction with
    partyIdentifier: Text
    contractIdentifier: Text
    vk: Optional Text
    party: Party
      deriving (Show, Eq)
    

  template Vault
    with
      owner: Party
      vault: Text
        where
          signatory owner

  template VaultState
    with 
      owner: Party
      operator: Party
      currentPartyIndex: Int
      currentContractIndex: Int
        where
          signatory owner, operator


          key owner : Party
          maintainer key

          choice VaultState_SendFunds: ContractId LvlTransferRequest
            with
              fromPartyIdentifier: Text
              fromContractIdentifier: Text
              requestId: Text
              requestor: Party
              to: [ Recipient ]
              contractParticipants: [ Party ]
            controller requestor
            do
              someSmartContractAddress <- lookupByKey @SmartContractAddress (requestor, fromPartyIdentifier, fromContractIdentifier)
              assertMsg "Smart Contract Address does not exist" (isSome someSmartContractAddress)
              smartContractAddress <- fetch $ fromSome someSmartContractAddress
              someSmartContract <- lookupByKey @SmartContract (operator, smartContractAddress.address)
              assert (isSome someSmartContract)
              smartContract <- fetch $ fromSome someSmartContract
              assert (requestor `elem` smartContract.canSend)
              exercise (fromSome someSmartContract) SmartContract_SendFunds with
                requestId = requestId
                requestor = requestor
                to = to
                contractParticipants = contractParticipants

          choice VaultState_AcceptInvitation : ContractId WalletParty
            with
              invitationAccept: PrivateWalletPartyToAdd
            controller owner
            do
              let newPartyIndex = currentPartyIndex + 1
              create VaultState with 
                currentPartyIndex = newPartyIndex 
                ..
              create WalletParty with
                index = newPartyIndex
                identifier = invitationAccept.identifier
                parties = invitationAccept.parties
                ..

          choice VaultState_CreateWalletContract : ContractId WalletContract
            with
              identifier: Text
              contract: Text
            controller owner
            do
              let newContractIndex = currentContractIndex + 1
              create VaultState with 
                currentContractIndex = newContractIndex 
                ..
              create WalletContract with
                index = newContractIndex
                contract = contract
                identifier = identifier
                ..
          
          nonconsuming choice VaultState_InviteParty : [ContractId WalletPartyInvitation]
            with
              invitationUUID: Text
              parties: [ Party ]
            controller owner
            do
              mapA 
                (\p -> create WalletPartyInvitation with
                  invitedParties = parties
                  party = p
                  ownerCloudWallet = True
                  ..)
                parties

          nonconsuming choice VaultState_InviteToInteraction: [ContractId WalletInteractionInvitation]
            with
              invitationUUID: Text
              partyIdentifier: Text
              contractIdentifier: Text
              canSend: [ Party ]
              vk: Optional Text
            controller owner
            do
              -- owner can send ==> vk must be set
              assert (owner `notElem` canSend || isSome vk)
              someWalletParty <- lookupByKey @WalletParty (owner, partyIdentifier)
              assertMsg "Party not found" (isSome someWalletParty)
              walletParty <- fetch $ fromSome someWalletParty
              someWalletContract <- lookupByKey @WalletContract (owner, contractIdentifier)
              assertMsg "Contract not found" (isSome someWalletContract)
              contract <- fetch $ fromSome someWalletContract
              mapA
                (\p -> create WalletInteractionInvitation with
                  invitedParties = canSend
                  contractTemplate = contract.contract
                  party = p
                  ..)
                 canSend
 
  template WalletInvitationAccepted
    with
      owner: Party
      operator: Party
      invitee: Party
      parties: [ Party ]
      cloudWallet: Bool
        where
          signatory owner, operator
          observer invitee

          choice WalletInvitationAccepted_MakePrivate: ContractId PrivateWalletPartyToAdd
            with
              identifier: Text
            controller invitee
            do
              create PrivateWalletPartyToAdd with
                owner = invitee
                ..


  template PrivateWalletPartyToAdd with
      owner: Party
      identifier: Text
      operator: Party
      parties: [Party]
      cloudWallet: Bool
        where
          signatory owner, operator

          choice PrivateWalletPartyToAdd_AddParty: ()
            controller operator
            do
              if cloudWallet
                then do
                  (theVaultId, theVault) <- fetchByKey @VaultState owner
                  exercise theVaultId VaultState_AcceptInvitation with
                    invitationAccept = this
                  return ()
                else do
                  return ()



  template WalletInvitationState
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      invitedParties: [ Party ]
      acceptedParties: [ Party ]
      ownerCloudWallet: Bool
      cloudWallet: Bool
        where
          signatory owner, operator
          observer invitedParties, acceptedParties

          key (owner, invitationUUID): (Party, Text)

          maintainer key._1

          choice WalletInvitationState_Accept : ContractId WalletInvitationState
            with
              party: Party
            controller operator
            do
              assertMsg "Party already accepted invitation" (party `notElem` acceptedParties) 
              create this with 
                invitedParties = filter (/= party) invitedParties
                acceptedParties = party :: acceptedParties


          choice WalletInvitationState_Distribute: [ ContractId WalletInvitationAccepted ]
            controller operator
            do
              invitedParties === []
              if owner `notElem` acceptedParties
                then do
                  ownInvitation <- create WalletInvitationAccepted with
                    invitee = owner
                    parties = acceptedParties
                    cloudWallet = ownerCloudWallet
                    ..
                  invitationList <- mapA
                    (\p -> 
                      create WalletInvitationAccepted with
                        invitee = p
                        parties = acceptedParties
                        ..)
                    acceptedParties
                  return (ownInvitation :: invitationList)
                else do
                  mapA
                    (\p -> 
                      create WalletInvitationAccepted with
                        invitee = p
                        parties = acceptedParties
                        ..)
                    acceptedParties

  template SmartContractAddress
    with
      owner: Party
      operator: Party
      partyIdentifier: Text
      contractIdentifier: Text
      state: Int
      address: Text
        where
          signatory owner, operator


          key (owner, partyIdentifier, contractIdentifier): (Party, Text, Text)
          maintainer key._1

          choice SmartContractAddress_UpdateState: ContractId SmartContractAddress
            with
              newState: Int
              newAddress : Text
            controller operator
            do
              create this with
                state = newState
                address = newAddress

  template SmartContract
    with
      operator: Party
      address: Text
      changeAddress: Text
      lock: Text
      contractTemplate: Text
      currentState: Int
      canSend: [ Party ]
      isValid: Bool
      acceptedParties: [ AcceptedInteraction ]
        where
          signatory operator
          observer fmap (.party) acceptedParties

          key (operator, address): (Party, Text)
          maintainer key._1

          choice SmartContract_SendFunds : ContractId LvlTransferRequest with
              requestId : Text
              requestor: Party
              to: [ Recipient ] 
              contractParticipants: [ Party ]
            controller requestor
            do
              assert (requestor `elem` canSend)
              assert isValid
              create this with isValid = False
              create LvlTransferRequest with
                from = SendAddress with ..
                ..
    

          choice SmartContract_UpdateState: ContractId SmartContract
            with
              newState: Int
              newLock: Text
              newAddress : Text
              newChangeAddress : Text
            controller operator
            do
              res <- mapA
                (\p -> do
                  exerciseByKey @SmartContractAddress (p.party, p.partyIdentifier, p.contractIdentifier) SmartContractAddress_UpdateState with
                    newState = newState
                    newAddress = newAddress
                  )
                acceptedParties
              create this with
                currentState = newState
                address = newAddress
                lock = newLock
                changeAddress = newChangeAddress
                isValid = True
 
  template InteractionInvitationState
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      contractTemplate: Text
      invitedParties: [ Party ]
      canSend: [ Party ]
      toGetInteraction : [ AcceptedInteraction ]
      acceptedParties: [ AcceptedInteraction ]
        where
          signatory owner, operator
          observer invitedParties, fmap (.party) acceptedParties

          key (owner, invitationUUID): (Party, Text)

          maintainer key._1

          choice InteractionInvitationState_Accept : ContractId InteractionInvitationState
            with
              party: Party
              partyIdentifier: Text
              contractIdentifier: Text
              vk: Optional Text
            controller operator
            do
              assertMsg "Party already accepted invitation" (party `notElem` fmap (\x -> x.party) acceptedParties) 
              create this with 
                invitedParties = filter (/= party) invitedParties
                toGetInteraction = (AcceptedInteraction with ..) :: toGetInteraction
                acceptedParties = (AcceptedInteraction with ..) :: acceptedParties


          choice InteractionInvitationState_GetInteration: ContractId InteractionInvitationState
            with
              requestor: Party
              address: Text
            controller requestor
            do
              invitedParties === []
              assertMsg "Party has already gotten interaction" (requestor `elem` fmap (.party) toGetInteraction)
              let p = head $ filter (\x -> x.party == requestor) toGetInteraction
              create SmartContractAddress with
                                owner = requestor
                                state = 1
                                partyIdentifier = p.partyIdentifier
                                contractIdentifier = p.contractIdentifier
                                address = address
                                ..
              create this with 
                toGetInteraction = filter (\x -> x.party /= requestor) toGetInteraction
                


          choice InteractionInvitationState_ToSmartContract: ContractId SmartContract
            with
              address: Text
              changeAddress: Text
              lock: Text
            controller operator
            do
              invitedParties === []
              toGetInteraction === []
              create SmartContract with
                currentState = 1
                isValid = True
                ..


  template WalletParty
    with
      owner: Party
      identifier: Text
      index: Int
      parties: [ Party ]
        where
          signatory owner

          key (owner, identifier): (Party, Text)
          maintainer key._1

  template WalletPartyInvitation
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      invitedParties: [ Party ]
      ownerCloudWallet: Bool
      party: Party
        where
          signatory owner, operator

          observer party


          choice WalletPartyInvitation_Accept : ContractId WalletInvitationState with
              cloudWallet: Bool
            controller party
            do
              someWalletState <- lookupByKey @WalletInvitationState (owner, invitationUUID)
              invitationAccepted <- optional 
                (create WalletInvitationState with
                  owner = owner
                  acceptedParties = [  ]
                  ..) 
                return
                someWalletState
              exercise invitationAccepted WalletInvitationState_Accept with
               ..

  template WalletInteractionInvitation
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      vk : Optional Text
      contractTemplate: Text
      invitedParties: [ Party ]
      party: Party
      canSend: [ Party ]
        where
          signatory owner, operator

          ensure
            party `elem` canSend

          observer party

          choice WalletInteractionInvitation_Accept : ContractId InteractionInvitationState
            with
              partyIdentifier: Text
              contractIdentifier: Text
            controller party
            do
              someWalletParty <- lookupByKey @WalletParty (party, partyIdentifier)
              assertMsg "Party not found" (isSome someWalletParty)
              walletParty <- fetch $ fromSome someWalletParty
              someContract <- lookupByKey @WalletContract (owner, contractIdentifier)
              assertMsg "Contract not found" (isSome someContract)
              contract <- fetch $ fromSome someContract
              assertMsg "Contract template is not the same" (contract.contract == contractTemplate)
              someWalletState <- lookupByKey @InteractionInvitationState (owner, invitationUUID)
              invitationAccepted <- optional 
                (create InteractionInvitationState with
                  owner = owner
                  acceptedParties = [  ]
                  toGetInteraction = [ ]
                  ..) 
                return
                someWalletState
              exercise invitationAccepted InteractionInvitationState_Accept with
               ..



  template WalletContract
    with
      owner: Party
      index: Int
      identifier: Text
      contract: Text
        where
          signatory owner

          key (owner, identifier): (Party, Text)
          maintainer key._1