module Topl.Wallet where

  import DA.Assert

  template Vault
    with 
      owner: Party
      operator: Party
      vault: Text
      password: Text
      currentPartyIndex: Int
      currentContractIndex: Int
        where
          signatory owner, operator


          key owner : Party
          maintainer key

          choice Vault_AcceptInvitation : ContractId WalletParty
            with
              invitationAccept: PrivateWalletPartyToAdd
            controller owner
            do
              let newPartyIndex = currentPartyIndex + 1
              create Vault with 
                currentPartyIndex = newPartyIndex 
                ..
              create WalletParty with
                index = newPartyIndex
                parties = invitationAccept.parties
                ..

          choice Vault_AcceptContractProposal : ContractId WalletContract
            with
              contractAccept: WalletContractProposal
            controller owner
            do
              let newContractIndex = currentContractIndex + 1
              create Vault with 
                currentContractIndex = newContractIndex 
                ..
              create WalletContract with
                index = newContractIndex
                ..

          choice Vault_CreateWalletContract : ContractId WalletContractProposal
            with
              contract: Text
            controller owner
            do
              let newContractIndex = currentContractIndex + 1
              create WalletContractProposal with
                ..
          
          nonconsuming choice Vault_InviteParty : [ContractId WalletPartyInvitation]
            with
              invitationUUID: Text
              parties: [ Party ]
            controller owner
            do
              let newPartyIndex = currentPartyIndex + 1
              mapA 
                (\p -> create WalletPartyInvitation with
                  invitedParties = parties
                  party = p
                  ..)
                parties  
 
  template WalletInvitationAccepted
    with
      owner: Party
      operator: Party
      invitee: Party
      parties: [ Party ]
        where
          signatory owner, operator
          observer invitee

          choice WalletInvitationAccepted_MakePrivate: ContractId PrivateWalletPartyToAdd
            controller invitee
            do
              create PrivateWalletPartyToAdd with
                owner = invitee
                ..

  template PrivateWalletPartyToAdd with
      owner: Party
      operator: Party
      parties: [Party]
        where
          signatory owner, operator

          choice PrivateWalletPartyToAdd_AddParty: ContractId WalletParty
            controller operator
            do
              (theVaultId, theVault) <- fetchByKey @Vault owner
              exercise theVaultId Vault_AcceptInvitation with
                invitationAccept = this



  template WalletInvitationState
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      invitedParties: [ Party ]
      acceptedParties: [ Party ]
        where
          signatory owner, operator
          observer invitedParties, acceptedParties

          key (owner, invitationUUID): (Party, Text)

          maintainer key._1

          choice WalletInvitationAccepted_Accept : ContractId WalletInvitationState
            with
              party: Party
            controller owner
            do
              assertMsg "Party already accepted invitation" (party `notElem` acceptedParties) 
              create this with 
                invitedParties = filter (/= party) invitedParties
                acceptedParties = party :: acceptedParties


          choice WalletInvitationAccepted_Distribute: [ ContractId WalletInvitationAccepted ]
            controller operator
            do
              invitedParties === []
              mapA
                (\p -> 
                  create WalletInvitationAccepted with
                    invitee = p
                    parties = acceptedParties
                    ..)
                acceptedParties



  template WalletParty
    with
      owner: Party
      index: Int
      parties: [ Party ]
        where
          signatory owner

  template WalletPartyInvitation
    with
      owner: Party
      operator: Party
      invitationUUID: Text
      invitedParties: [ Party ]
      party: Party
        where
          signatory owner, operator

          observer party

          choice WalletPartyInvitation_Accept : ContractId WalletInvitationState
            controller party
            do
              someWalletState <- lookupByKey @WalletInvitationState (owner, invitationUUID)
              invitationAccepted <- optional 
                (create WalletInvitationState with
                  owner = owner
                  acceptedParties = [ owner ]
                  ..) 
                return
                someWalletState
              exercise invitationAccepted WalletInvitationAccepted_Accept with
               ..

  template WalletContractProposal
    with
      owner: Party
      operator: Party
      contract: Text
        where
          signatory owner

          choice WalletContractProposal_Accept : ContractId WalletContract
            controller operator
            do
              (theVaultId, theVault) <- fetchByKey @Vault owner
              exercise theVaultId Vault_AcceptContractProposal with
                contractAccept = this



  template WalletContract
    with
      owner: Party
      index: Int
        where
          signatory owner